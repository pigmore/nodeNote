<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Note Taking App - Canvas</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: Arial, sans-serif;
        background-color: #f0f0f0;
        overflow: hidden;
      }

      .container {
        width: 100vw;
        height: 100vh;
        position: relative;
      }

      #canvas {
        cursor: grab;
        background-color: #ffffff;
        border: 1px solid #ddd;
      }

      #canvas:active {
        cursor: grabbing;
      }

      .controls {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 1000;
      }

      .control-btn {
        width: 40px;
        height: 40px;
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 5px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: background-color 0.2s;
      }

      .control-btn:hover {
        background-color: #f5f5f5;
      }

      /* Floating Action Buttons - Bottom Right */
      .fab-container {
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        align-items: end;
        gap: 15px;
        z-index: 1000;
      }

      .fab-btn {
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        transition: all 0.2s ease;
      }

      .fab-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
      }

      .fab-btn.fab-primary {
        width: 60px;
        height: 60px;
        font-size: 24px;
        font-weight: bold;
      }

      .fab-btn.fab-secondary {
        width: 48px;
        height: 48px;
        font-size: 20px;
      }

      .control-btn.add-node {
        background-color: #4caf50;
        color: white;
      }

      .control-btn.add-node:hover,
      .fab-btn.add-node:hover {
        background-color: #45a049;
      }

      .fab-btn.add-node {
        background-color: #4caf50;
        color: white;
      }

      .control-btn.add-link {
        background-color: #9c27b0;
        color: white;
      }

      .control-btn.add-link:hover,
      .fab-btn.add-link:hover {
        background-color: #7b1fa2;
      }

      .fab-btn.add-link {
        background-color: #9c27b0;
        color: white;
      }

      .control-btn.add-link.active,
      .fab-btn.add-link.active {
        background-color: #e91e63;
        box-shadow: 0 0 10px rgba(233, 30, 99, 0.5);
      }

      .fab-btn.add-link.active:hover {
        background-color: #c2185b;
      }

      .control-btn.export {
        background-color: #2196f3;
        color: white;
      }

      .control-btn.export:hover {
        background-color: #1976d2;
      }

      .control-btn.import {
        background-color: #ff9800;
        color: white;
      }

      .control-btn.import:hover {
        background-color: #f57c00;
      }

      .info {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
        color: #666;
        z-index: 1000;
      }

      /* Text input overlay for editing nodes */
      .text-input-overlay {
        position: absolute;
        display: none;
        z-index: 1001;
      }

      .text-input-overlay input {
        border: 2px solid #4caf50;
        border-radius: 4px;
        padding: 8px;
        font-size: 14px;
        background: white;
        outline: none;
        min-width: 150px;
      }

      /* Import dialog styles */
      .import-dialog {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 2000;
      }

      .import-dialog-content {
        background: white;
        padding: 20px;
        border-radius: 8px;
        width: 90%;
        max-width: 500px;
        max-height: 80%;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .import-dialog h3 {
        margin: 0;
        color: #333;
      }

      .import-dialog textarea {
        width: 100%;
        height: 200px;
        border: 2px solid #ddd;
        border-radius: 4px;
        padding: 10px;
        font-family: monospace;
        font-size: 12px;
        resize: vertical;
        outline: none;
      }

      .import-dialog textarea:focus {
        border-color: #4caf50;
      }

      .import-dialog-buttons {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }

      .import-dialog button {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }

      .import-dialog .btn-primary {
        background-color: #4caf50;
        color: white;
      }

      .import-dialog .btn-primary:hover {
        background-color: #45a049;
      }

      .import-dialog .btn-secondary {
        background-color: #ddd;
        color: #333;
      }

      .import-dialog .btn-secondary:hover {
        background-color: #ccc;
      }

      .error-message {
        color: #f44336;
        font-size: 12px;
        margin: 0;
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <canvas id="canvas"></canvas>

      <div class="controls">
        <button class="control-btn export" id="exportBtn" title="Export Project">üíæ</button>
        <button class="control-btn import" id="importBtn" title="Import Project">üìÅ</button>
        <button class="control-btn" id="zoomIn" title="Zoom In">+</button>
        <button class="control-btn" id="zoomOut" title="Zoom Out">‚àí</button>
        <button class="control-btn" id="reset" title="Reset View">‚åÇ</button>
      </div>

      <!-- Floating Action Buttons -->
      <div class="fab-container">
        <button class="fab-btn fab-secondary add-link" id="addLink" title="Add Link">üîó</button>
        <button class="fab-btn fab-primary add-node" id="addNode" title="Add Node">+</button>
      </div>

      <div class="info">
        <div>Zoom: <span id="zoomLevel">100%</span></div>
        <div>Position: (<span id="posX">0</span>, <span id="posY">0</span>)</div>
        <div>Nodes: <span id="nodeCount">0</span></div>
        <div>Links: <span id="linkCount">0</span></div>
        <div>Use mouse wheel to zoom, drag to pan</div>
        <div>Click nodes to edit text, drag nodes to move</div>
        <div id="linkModeInfo" style="display: none; color: #9c27b0; font-weight: bold">
          Link Mode: Click two nodes to connect them
        </div>
      </div>

      <!-- Text input overlay for editing node text -->
      <div class="text-input-overlay" id="textInputOverlay">
        <input type="text" id="textInput" placeholder="Enter text..." />
      </div>

      <!-- Import dialog -->
      <div class="import-dialog" id="importDialog">
        <div class="import-dialog-content">
          <h3>Import Project Data</h3>
          <p>Paste your exported project data below:</p>
          <textarea id="importTextarea" placeholder="Paste project JSON data here..."></textarea>
          <p class="error-message" id="importError"></p>
          <div class="import-dialog-buttons">
            <button class="btn-secondary" id="importCancel">Cancel</button>
            <button class="btn-primary" id="importConfirm">Import</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Node class to represent individual nodes
      class Node {
        constructor(x, y, text = 'New Node') {
          this.id = Math.random().toString(36).substr(2, 9);
          this.x = x;
          this.y = y;
          this.text = text;
          this.width = 120;
          this.height = 40;
          this.minWidth = 80;
          this.minHeight = 30;
          this.maxWidth = 300;
          this.maxHeight = 150;
          this.isDragging = false;
          this.dragOffsetX = 0;
          this.dragOffsetY = 0;
          this.isSelected = false;
          this.isResizing = false;
          this.resizeHandle = null; // 'right', 'bottom', 'corner'
        }

        // Check if a point is inside this node
        contains(x, y) {
          return (
            x >= this.x - this.width / 2 &&
            x <= this.x + this.width / 2 &&
            y >= this.y - this.height / 2 &&
            y <= this.y + this.height / 2
          );
        }

        // Check if a point is on a resize handle
        getResizeHandle(x, y, scale) {
          if (!this.isSelected) return null;

          const handleSize = 8 / scale;
          const nodeLeft = this.x - this.width / 2;
          const nodeRight = this.x + this.width / 2;
          const nodeTop = this.y - this.height / 2;
          const nodeBottom = this.y + this.height / 2;

          // Right edge handle
          if (Math.abs(x - nodeRight) <= handleSize && y >= nodeTop && y <= nodeBottom) {
            return 'right';
          }

          // Bottom edge handle
          if (Math.abs(y - nodeBottom) <= handleSize && x >= nodeLeft && x <= nodeRight) {
            return 'bottom';
          }

          // Corner handle (bottom-right)
          if (Math.abs(x - nodeRight) <= handleSize && Math.abs(y - nodeBottom) <= handleSize) {
            return 'corner';
          }

          return null;
        }

        // Resize the node
        resize(newWidth, newHeight) {
          this.width = Math.max(this.minWidth, Math.min(this.maxWidth, newWidth));
          this.height = Math.max(this.minHeight, Math.min(this.maxHeight, newHeight));
        }

        // Draw the node on the canvas
        draw(ctx, scale) {
          ctx.save();

          const x = this.x - this.width / 2;
          const y = this.y - this.height / 2;

          // Draw selection highlight
          if (this.isSelected) {
            ctx.fillStyle = 'rgba(74, 175, 79, 0.1)';
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3 / scale;
            ctx.beginPath();
            ctx.roundRect(x - 2 / scale, y - 2 / scale, this.width + 4 / scale, this.height + 4 / scale, 8);
            ctx.fill();
            ctx.stroke();
          }

          // Draw node background
          ctx.fillStyle = '#ffffff';
          ctx.strokeStyle = this.isSelected ? '#4CAF50' : '#333333';
          ctx.lineWidth = 2 / scale;

          // Draw rounded rectangle
          ctx.beginPath();
          ctx.roundRect(x, y, this.width, this.height, 8);
          ctx.fill();
          ctx.stroke();

          // Draw text
          ctx.fillStyle = '#333333';
          ctx.font = `${14 / scale}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // Truncate text if too long
          let displayText = this.text;
          const maxWidth = this.width - 10;
          const textWidth = ctx.measureText(displayText).width;

          if (textWidth > maxWidth) {
            while (ctx.measureText(displayText + '...').width > maxWidth && displayText.length > 0) {
              displayText = displayText.slice(0, -1);
            }
            displayText += '...';
          }

          ctx.fillText(displayText, this.x, this.y);

          // Draw resize handles if selected
          if (this.isSelected) {
            this.drawResizeHandles(ctx, scale);
          }

          ctx.restore();
        }

        // Draw resize handles
        drawResizeHandles(ctx, scale) {
          const handleSize = 6 / scale;
          const nodeRight = this.x + this.width / 2;
          const nodeBottom = this.y + this.height / 2;

          ctx.fillStyle = '#4CAF50';
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1 / scale;

          // Right edge handle
          ctx.beginPath();
          ctx.rect(nodeRight - handleSize / 2, this.y - handleSize / 2, handleSize, handleSize);
          ctx.fill();
          ctx.stroke();

          // Bottom edge handle
          ctx.beginPath();
          ctx.rect(this.x - handleSize / 2, nodeBottom - handleSize / 2, handleSize, handleSize);
          ctx.fill();
          ctx.stroke();

          // Corner handle (bottom-right)
          ctx.beginPath();
          ctx.rect(nodeRight - handleSize / 2, nodeBottom - handleSize / 2, handleSize, handleSize);
          ctx.fill();
          ctx.stroke();
        }
      }

      // Link class to represent connections between nodes
      class Link {
        constructor(startNode, endNode) {
          this.id = Math.random().toString(36).substr(2, 9);
          this.startNode = startNode;
          this.endNode = endNode;
          this.startNodeId = startNode.id;
          this.endNodeId = endNode.id;

          // Calculate initial control point position (midpoint with some offset)
          const midX = (startNode.x + endNode.x) / 2;
          const midY = (startNode.y + endNode.y) / 2;

          // Add some perpendicular offset for a nice curve
          const dx = endNode.x - startNode.x;
          const dy = endNode.y - startNode.y;
          const length = Math.sqrt(dx * dx + dy * dy);

          if (length > 0) {
            const normalX = -dy / length;
            const normalY = dx / length;
            const offset = Math.min(50, length * 0.3);

            this.controlX = midX + normalX * offset;
            this.controlY = midY + normalY * offset;
          } else {
            this.controlX = midX;
            this.controlY = midY - 30;
          }

          this.isSelected = false;
          this.controlRadius = 6;
        }

        // Check if a point is near the control point
        isControlPointHit(x, y, scale) {
          const radius = this.controlRadius / scale;
          const dx = x - this.controlX;
          const dy = y - this.controlY;
          return dx * dx + dy * dy <= radius * radius;
        }

        // Check if a point is near the bezier curve
        isCurveHit(x, y, scale) {
          const threshold = 8 / scale;

          // Sample points along the bezier curve and check distance
          for (let t = 0; t <= 1; t += 0.05) {
            const curvePoint = this.getBezierPoint(t);
            const dx = x - curvePoint.x;
            const dy = y - curvePoint.y;
            if (Math.sqrt(dx * dx + dy * dy) <= threshold) {
              return true;
            }
          }
          return false;
        }

        // Get a point on the bezier curve at parameter t (0 to 1)
        getBezierPoint(t) {
          const startX = this.startNode.x;
          const startY = this.startNode.y;
          const endX = this.endNode.x;
          const endY = this.endNode.y;

          // Quadratic bezier curve formula
          const x = (1 - t) * (1 - t) * startX + 2 * (1 - t) * t * this.controlX + t * t * endX;
          const y = (1 - t) * (1 - t) * startY + 2 * (1 - t) * t * this.controlY + t * t * endY;

          return { x, y };
        }

        // Draw the link
        draw(ctx, scale) {
          ctx.save();

          // Draw bezier curve
          ctx.strokeStyle = this.isSelected ? '#9C27B0' : '#666666';
          ctx.lineWidth = this.isSelected ? 3 / scale : 2 / scale;
          ctx.lineCap = 'round';

          ctx.beginPath();
          ctx.moveTo(this.startNode.x, this.startNode.y);
          ctx.quadraticCurveTo(this.controlX, this.controlY, this.endNode.x, this.endNode.y);
          ctx.stroke();

          // Draw arrowhead at the end
          this.drawArrowhead(ctx, scale);

          // Draw control point if selected
          if (this.isSelected) {
            this.drawControlPoint(ctx, scale);
            this.drawControlLines(ctx, scale);
          }

          ctx.restore();
        }

        // Draw arrowhead at the end of the link
        drawArrowhead(ctx, scale) {
          const arrowSize = 8 / scale;

          // Get the direction at the end of the curve
          const t = 0.95; // Slightly before the end to get good direction
          const p1 = this.getBezierPoint(t);
          const p2 = this.getBezierPoint(1);

          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const length = Math.sqrt(dx * dx + dy * dy);

          if (length > 0) {
            const unitX = dx / length;
            const unitY = dy / length;

            // Calculate arrowhead points
            const arrowX1 = p2.x - arrowSize * unitX - arrowSize * 0.5 * unitY;
            const arrowY1 = p2.y - arrowSize * unitY + arrowSize * 0.5 * unitX;
            const arrowX2 = p2.x - arrowSize * unitX + arrowSize * 0.5 * unitY;
            const arrowY2 = p2.y - arrowSize * unitY - arrowSize * 0.5 * unitX;

            ctx.fillStyle = this.isSelected ? '#9C27B0' : '#666666';
            ctx.beginPath();
            ctx.moveTo(p2.x, p2.y);
            ctx.lineTo(arrowX1, arrowY1);
            ctx.lineTo(arrowX2, arrowY2);
            ctx.closePath();
            ctx.fill();
          }
        }

        // Draw control point
        drawControlPoint(ctx, scale) {
          const radius = this.controlRadius / scale;

          ctx.fillStyle = '#9C27B0';
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2 / scale;

          ctx.beginPath();
          ctx.arc(this.controlX, this.controlY, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }

        // Draw control lines (from start/end to control point)
        drawControlLines(ctx, scale) {
          ctx.strokeStyle = 'rgba(156, 39, 176, 0.3)';
          ctx.lineWidth = 1 / scale;
          ctx.setLineDash([5 / scale, 5 / scale]);

          // Line from start to control
          ctx.beginPath();
          ctx.moveTo(this.startNode.x, this.startNode.y);
          ctx.lineTo(this.controlX, this.controlY);
          ctx.stroke();

          // Line from control to end
          ctx.beginPath();
          ctx.moveTo(this.controlX, this.controlY);
          ctx.lineTo(this.endNode.x, this.endNode.y);
          ctx.stroke();

          ctx.setLineDash([]);
        }
      }

      class CanvasMap {
        constructor(canvasId) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext('2d');

          // Canvas properties
          this.scale = 1;
          this.translateX = 0;
          this.translateY = 0;

          // Grid properties
          this.gridSize = 20;

          // Mouse properties
          this.isDragging = false;
          this.lastMouseX = 0;
          this.lastMouseY = 0;

          // Node properties
          this.nodes = [];
          this.selectedNode = null;
          this.isDraggingNode = false;
          this.isResizingNode = false;
          this.resizeStartX = 0;
          this.resizeStartY = 0;
          this.resizeStartWidth = 0;
          this.resizeStartHeight = 0;

          // Link properties
          this.links = [];
          this.selectedLink = null;
          this.isLinkMode = false;
          this.linkModeFirstNode = null;
          this.isDraggingControlPoint = false;

          // Text editing
          this.editingNode = null;
          this.textInputOverlay = document.getElementById('textInputOverlay');
          this.textInput = document.getElementById('textInput');

          // Import dialog
          this.importDialog = document.getElementById('importDialog');
          this.importTextarea = document.getElementById('importTextarea');
          this.importError = document.getElementById('importError');
          this.importCancelBtn = document.getElementById('importCancel');
          this.importConfirmBtn = document.getElementById('importConfirm');

          // Initialize
          this.setupCanvas();
          this.setupEventListeners();
          this.draw();
        }

        setupCanvas() {
          // Make canvas fill the window
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;

          // Set initial position to center
          this.translateX = this.canvas.width / 2;
          this.translateY = this.canvas.height / 2;
        }

        // Convert screen coordinates to world coordinates
        screenToWorld(screenX, screenY) {
          const worldX = (screenX - this.translateX) / this.scale;
          const worldY = (screenY - this.translateY) / this.scale;
          return { x: worldX, y: worldY };
        }

        // Convert world coordinates to screen coordinates
        worldToScreen(worldX, worldY) {
          const screenX = worldX * this.scale + this.translateX;
          const screenY = worldY * this.scale + this.translateY;
          return { x: screenX, y: screenY };
        }

        // Find node at given world coordinates
        findNodeAt(worldX, worldY) {
          for (let i = this.nodes.length - 1; i >= 0; i--) {
            if (this.nodes[i].contains(worldX, worldY)) {
              return this.nodes[i];
            }
          }
          return null;
        }

        // Add a new node
        addNode(worldX = 0, worldY = 0) {
          const node = new Node(worldX, worldY);
          this.nodes.push(node);
          this.updateNodeCount();
          this.draw();
          return node;
        }

        // Start editing a node's text
        startEditingNode(node) {
          this.editingNode = node;
          this.textInput.value = node.text;

          // Position the input overlay
          const screenPos = this.worldToScreen(node.x, node.y);
          this.textInputOverlay.style.left = screenPos.x - 75 + 'px';
          this.textInputOverlay.style.top = screenPos.y - 15 + 'px';
          this.textInputOverlay.style.display = 'block';

          this.textInput.focus();
          this.textInput.select();
        }

        // Finish editing node text
        finishEditingNode() {
          if (this.editingNode) {
            this.editingNode.text = this.textInput.value || 'New Node';
            this.editingNode = null;
            this.textInputOverlay.style.display = 'none';
            this.draw();
          }
        }

        setupEventListeners() {
          // Mouse events
          this.canvas.addEventListener('mousedown', e => {
            const rect = this.canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const worldPos = this.screenToWorld(screenX, screenY);

            // Check if clicking on a node
            const clickedNode = this.findNodeAt(worldPos.x, worldPos.y);

            if (this.isLinkMode && clickedNode) {
              // Handle link creation mode
              this.handleLinkModeClick(clickedNode);
              return;
            }

            if (clickedNode) {
              // Check if clicking on a resize handle
              const resizeHandle = clickedNode.getResizeHandle(worldPos.x, worldPos.y, this.scale);

              if (resizeHandle && clickedNode.isSelected) {
                // Start resizing
                this.isResizingNode = true;
                this.selectedNode = clickedNode;
                clickedNode.isResizing = true;
                clickedNode.resizeHandle = resizeHandle;
                this.resizeStartX = worldPos.x;
                this.resizeStartY = worldPos.y;
                this.resizeStartWidth = clickedNode.width;
                this.resizeStartHeight = clickedNode.height;

                // Set cursor based on resize handle
                if (resizeHandle === 'right') {
                  this.canvas.style.cursor = 'ew-resize';
                } else if (resizeHandle === 'bottom') {
                  this.canvas.style.cursor = 'ns-resize';
                } else if (resizeHandle === 'corner') {
                  this.canvas.style.cursor = 'nw-resize';
                }
              } else {
                // Select and start dragging node
                this.selectNode(clickedNode);
                this.selectLink(null); // Deselect any selected link
                this.isDraggingNode = true;
                clickedNode.isDragging = true;
                clickedNode.dragOffsetX = worldPos.x - clickedNode.x;
                clickedNode.dragOffsetY = worldPos.y - clickedNode.y;
              }
            } else {
              // Check if clicking on a link or its control point
              const clickedLink = this.findLinkAt(worldPos.x, worldPos.y);

              if (clickedLink) {
                // Check if clicking on control point
                if (clickedLink.isControlPointHit(worldPos.x, worldPos.y, this.scale)) {
                  this.selectLink(clickedLink);
                  this.isDraggingControlPoint = true;
                  this.canvas.style.cursor = 'move';
                } else {
                  // Just select the link
                  this.selectLink(clickedLink);
                  this.selectNode(null); // Deselect any selected node
                }
              } else {
                // Deselect all and start canvas panning
                this.selectNode(null);
                this.selectLink(null);
                this.isDragging = true;
              }
            }

            this.lastMouseX = e.clientX;
            this.lastMouseY = e.clientY;
          });

          this.canvas.addEventListener('mousemove', e => {
            const rect = this.canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const worldPos = this.screenToWorld(screenX, screenY);

            if (this.isDraggingControlPoint && this.selectedLink) {
              // Drag link control point
              this.selectedLink.controlX = worldPos.x;
              this.selectedLink.controlY = worldPos.y;
              this.draw();
            } else if (this.isResizingNode && this.selectedNode) {
              // Handle node resizing
              const node = this.selectedNode;
              const deltaX = worldPos.x - this.resizeStartX;
              const deltaY = worldPos.y - this.resizeStartY;

              if (node.resizeHandle === 'right') {
                node.resize(this.resizeStartWidth + deltaX, node.height);
              } else if (node.resizeHandle === 'bottom') {
                node.resize(node.width, this.resizeStartHeight + deltaY);
              } else if (node.resizeHandle === 'corner') {
                node.resize(this.resizeStartWidth + deltaX, this.resizeStartHeight + deltaY);
              }

              this.draw();
            } else if (this.isDraggingNode && this.selectedNode) {
              // Drag node
              this.selectedNode.x = worldPos.x - this.selectedNode.dragOffsetX;
              this.selectedNode.y = worldPos.y - this.selectedNode.dragOffsetY;

              this.draw();
            } else if (this.isDragging) {
              // Pan canvas
              const deltaX = e.clientX - this.lastMouseX;
              const deltaY = e.clientY - this.lastMouseY;

              this.translateX += deltaX;
              this.translateY += deltaY;

              this.lastMouseX = e.clientX;
              this.lastMouseY = e.clientY;

              this.draw();
              this.updateInfo();
            } else {
              // Update cursor based on hover state
              const hoveredNode = this.findNodeAt(worldPos.x, worldPos.y);
              const hoveredLink = this.findLinkAt(worldPos.x, worldPos.y);

              if (this.isLinkMode) {
                this.canvas.style.cursor = hoveredNode ? 'pointer' : 'crosshair';
              } else if (hoveredNode && hoveredNode.isSelected) {
                const resizeHandle = hoveredNode.getResizeHandle(worldPos.x, worldPos.y, this.scale);

                if (resizeHandle === 'right') {
                  this.canvas.style.cursor = 'ew-resize';
                } else if (resizeHandle === 'bottom') {
                  this.canvas.style.cursor = 'ns-resize';
                } else if (resizeHandle === 'corner') {
                  this.canvas.style.cursor = 'nw-resize';
                } else {
                  this.canvas.style.cursor = 'move';
                }
              } else if (hoveredNode) {
                this.canvas.style.cursor = 'pointer';
              } else if (hoveredLink) {
                if (hoveredLink.isControlPointHit(worldPos.x, worldPos.y, this.scale)) {
                  this.canvas.style.cursor = 'move';
                } else {
                  this.canvas.style.cursor = 'pointer';
                }
              } else {
                this.canvas.style.cursor = 'grab';
              }
            }
          });

          this.canvas.addEventListener('mouseup', e => {
            if (this.isDraggingControlPoint) {
              this.isDraggingControlPoint = false;
            } else if (this.isResizingNode && this.selectedNode) {
              this.selectedNode.isResizing = false;
              this.selectedNode.resizeHandle = null;
              this.isResizingNode = false;
            } else if (this.isDraggingNode && this.selectedNode) {
              this.selectedNode.isDragging = false;
              this.isDraggingNode = false;
            } else if (this.isDragging) {
              this.isDragging = false;
            }

            // Reset cursor
            this.canvas.style.cursor = this.isLinkMode ? 'crosshair' : 'grab';
          });

          // Double click to edit node text
          this.canvas.addEventListener('dblclick', e => {
            const rect = this.canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const worldPos = this.screenToWorld(screenX, screenY);

            const clickedNode = this.findNodeAt(worldPos.x, worldPos.y);
            if (clickedNode) {
              this.startEditingNode(clickedNode);
            }
          });

          this.canvas.addEventListener('mouseleave', () => {
            this.isDragging = false;
            this.isDraggingControlPoint = false;
            if (this.selectedNode) {
              this.selectedNode.isDragging = false;
              this.selectedNode.isResizing = false;
              this.isDraggingNode = false;
              this.isResizingNode = false;
            }
            this.canvas.style.cursor = 'grab';
          });

          // Mouse wheel for zooming
          this.canvas.addEventListener('wheel', e => {
            e.preventDefault();

            const mouseX = e.clientX;
            const mouseY = e.clientY;

            // Get mouse position relative to canvas
            const rect = this.canvas.getBoundingClientRect();
            const x = mouseX - rect.left;
            const y = mouseY - rect.top;

            // Calculate zoom
            const zoom = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = this.scale * zoom;

            // Limit zoom range
            if (newScale < 0.1 || newScale > 5) return;

            // Zoom towards mouse position
            this.translateX = x - (x - this.translateX) * zoom;
            this.translateY = y - (y - this.translateY) * zoom;
            this.scale = newScale;

            this.draw();
            this.updateInfo();
          });

          // Control buttons
          document.getElementById('addNode').addEventListener('click', () => {
            // Add node at center of view
            const centerWorld = this.screenToWorld(this.canvas.width / 2, this.canvas.height / 2);
            this.addNode(centerWorld.x, centerWorld.y);
          });

          document.getElementById('addLink').addEventListener('click', () => {
            this.toggleLinkMode();
          });

          document.getElementById('exportBtn').addEventListener('click', () => {
            this.exportProject();
          });

          document.getElementById('importBtn').addEventListener('click', () => {
            this.showImportDialog();
          });

          document.getElementById('zoomIn').addEventListener('click', () => {
            this.zoomAt(this.canvas.width / 2, this.canvas.height / 2, 1.2);
          });

          document.getElementById('zoomOut').addEventListener('click', () => {
            this.zoomAt(this.canvas.width / 2, this.canvas.height / 2, 0.8);
          });

          document.getElementById('reset').addEventListener('click', () => {
            this.reset();
          });

          // Text input events
          this.textInput.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
              this.finishEditingNode();
            } else if (e.key === 'Escape') {
              this.textInputOverlay.style.display = 'none';
              this.editingNode = null;
            }
          });

          this.textInput.addEventListener('blur', () => {
            this.finishEditingNode();
          });

          // Import dialog events
          this.importCancelBtn.addEventListener('click', () => {
            this.hideImportDialog();
          });

          this.importConfirmBtn.addEventListener('click', () => {
            const jsonString = this.importTextarea.value.trim();
            const errorElement = this.importError;

            if (!jsonString) {
              errorElement.textContent = 'Please paste project data';
              errorElement.style.display = 'block';
              return;
            }

            const success = this.importProject(jsonString);
            if (success) {
              this.hideImportDialog();
            } else {
              errorElement.textContent = 'Invalid project data. Please check the format and try again.';
              errorElement.style.display = 'block';
            }
          });

          // Close import dialog when clicking outside
          this.importDialog.addEventListener('click', e => {
            if (e.target.id === 'importDialog') {
              this.hideImportDialog();
            }
          });

          // Handle escape key in import dialog
          document.addEventListener('keydown', e => {
            if (e.key === 'Escape' && this.importDialog.style.display === 'flex') {
              this.hideImportDialog();
            }
          });

          // Window resize
          window.addEventListener('resize', () => {
            this.setupCanvas();
            this.draw();
          });
        }

        zoomAt(x, y, zoom) {
          const newScale = this.scale * zoom;
          if (newScale < 0.1 || newScale > 5) return;

          this.translateX = x - (x - this.translateX) * zoom;
          this.translateY = y - (y - this.translateY) * zoom;
          this.scale = newScale;

          this.draw();
          this.updateInfo();
        }

        reset() {
          this.scale = 1;
          this.translateX = this.canvas.width / 2;
          this.translateY = this.canvas.height / 2;
          this.draw();
          this.updateInfo();
        }

        drawGrid() {
          const scaledGridSize = this.gridSize * this.scale;

          // Skip drawing grid if too small or too large
          if (scaledGridSize < 5 || scaledGridSize > 200) return;

          this.ctx.strokeStyle = '#e0e0e0';
          this.ctx.lineWidth = 1;

          // Calculate grid offset
          const offsetX = this.translateX % scaledGridSize;
          const offsetY = this.translateY % scaledGridSize;

          // Draw vertical lines
          for (let x = offsetX; x < this.canvas.width; x += scaledGridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
          }

          // Draw horizontal lines
          for (let y = offsetY; y < this.canvas.height; y += scaledGridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
          }
        }

        drawOrigin() {
          // Draw origin point (0,0) as a small cross
          this.ctx.save();
          this.ctx.translate(this.translateX, this.translateY);
          this.ctx.scale(this.scale, this.scale);

          this.ctx.strokeStyle = '#ff0000';
          this.ctx.lineWidth = 2 / this.scale;

          // Draw cross
          this.ctx.beginPath();
          this.ctx.moveTo(-10 / this.scale, 0);
          this.ctx.lineTo(10 / this.scale, 0);
          this.ctx.moveTo(0, -10 / this.scale);
          this.ctx.lineTo(0, 10 / this.scale);
          this.ctx.stroke();

          this.ctx.restore();
        }

        drawNodes() {
          this.ctx.save();
          this.ctx.translate(this.translateX, this.translateY);
          this.ctx.scale(this.scale, this.scale);

          // Draw all nodes
          for (const node of this.nodes) {
            node.draw(this.ctx, this.scale);
          }

          this.ctx.restore();
        }

        drawLinks() {
          this.ctx.save();
          this.ctx.translate(this.translateX, this.translateY);
          this.ctx.scale(this.scale, this.scale);

          // Draw all links
          for (const link of this.links) {
            link.draw(this.ctx, this.scale);
          }

          this.ctx.restore();
        }

        draw() {
          // Clear canvas
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Draw grid
          this.drawGrid();

          // Draw origin
          this.drawOrigin();

          // Draw links first (behind nodes)
          this.drawLinks();

          // Draw nodes
          this.drawNodes();
        }

        updateInfo() {
          document.getElementById('zoomLevel').textContent = Math.round(this.scale * 100) + '%';
          document.getElementById('posX').textContent = Math.round(-this.translateX + this.canvas.width / 2);
          document.getElementById('posY').textContent = Math.round(-this.translateY + this.canvas.height / 2);
        }

        updateNodeCount() {
          document.getElementById('nodeCount').textContent = this.nodes.length;
        }

        updateLinkCount() {
          document.getElementById('linkCount').textContent = this.links.length;
        }

        // Export project data
        exportProject() {
          const projectData = {
            version: '1.0',
            timestamp: new Date().toISOString(),
            canvas: {
              scale: this.scale,
              translateX: this.translateX,
              translateY: this.translateY,
            },
            nodes: this.nodes.map(node => ({
              id: node.id,
              x: node.x,
              y: node.y,
              text: node.text,
              width: node.width,
              height: node.height,
            })),
            links: this.links.map(link => ({
              id: link.id,
              startNodeId: link.startNodeId,
              endNodeId: link.endNodeId,
              controlX: link.controlX,
              controlY: link.controlY,
            })),
          };

          const jsonString = JSON.stringify(projectData, null, 2);

          // Create download link
          const blob = new Blob([jsonString], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `nodenote-project-${new Date().toISOString().split('T')[0]}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }

        // Import project data
        importProject(jsonString) {
          try {
            const projectData = JSON.parse(jsonString);

            // Validate data structure
            if (!projectData.version || !projectData.nodes || !Array.isArray(projectData.nodes)) {
              throw new Error('Invalid project data format');
            }

            // Clear existing data
            this.nodes = [];
            this.links = [];

            // Restore canvas state if available
            if (projectData.canvas) {
              this.scale = projectData.canvas.scale || 1;
              this.translateX = projectData.canvas.translateX || this.canvas.width / 2;
              this.translateY = projectData.canvas.translateY || this.canvas.height / 2;
            }

            // Restore nodes
            const nodeMap = new Map();
            projectData.nodes.forEach(nodeData => {
              const node = new Node(nodeData.x, nodeData.y, nodeData.text);
              node.id = nodeData.id || node.id;
              node.width = nodeData.width || 120;
              node.height = nodeData.height || 40;
              this.nodes.push(node);
              nodeMap.set(node.id, node);
            });

            // Restore links if available
            if (projectData.links && Array.isArray(projectData.links)) {
              projectData.links.forEach(linkData => {
                const startNode = nodeMap.get(linkData.startNodeId);
                const endNode = nodeMap.get(linkData.endNodeId);

                if (startNode && endNode) {
                  const link = new Link(startNode, endNode);
                  link.id = linkData.id || link.id;
                  link.controlX = linkData.controlX || link.controlX;
                  link.controlY = linkData.controlY || link.controlY;
                  this.links.push(link);
                }
              });
            }

            this.updateNodeCount();
            this.updateLinkCount();
            this.draw();
            this.updateInfo();

            return true;
          } catch (error) {
            console.error('Import error:', error);
            return false;
          }
        }

        // Show import dialog
        showImportDialog() {
          this.importDialog.style.display = 'flex';
          this.importTextarea.value = '';
          this.importError.style.display = 'none';
          this.importTextarea.focus();
        }

        // Hide import dialog
        hideImportDialog() {
          this.importDialog.style.display = 'none';
        }

        // Select a node
        selectNode(node) {
          // Deselect all nodes first
          this.nodes.forEach(n => (n.isSelected = false));

          // Select the clicked node
          if (node) {
            node.isSelected = true;
            this.selectedNode = node;
          } else {
            this.selectedNode = null;
          }

          this.draw();
        }

        // Add a new link between two nodes
        addLink(startNode, endNode) {
          // Check if link already exists
          const existingLink = this.links.find(
            link =>
              (link.startNode === startNode && link.endNode === endNode) ||
              (link.startNode === endNode && link.endNode === startNode)
          );

          if (existingLink) {
            return null; // Link already exists
          }

          const link = new Link(startNode, endNode);
          this.links.push(link);
          this.updateLinkCount();
          this.draw();
          return link;
        }

        // Remove a link
        removeLink(link) {
          const index = this.links.indexOf(link);
          if (index !== -1) {
            this.links.splice(index, 1);
            this.updateLinkCount();
            this.draw();
          }
        }

        // Find link at given world coordinates
        findLinkAt(worldX, worldY) {
          for (let i = this.links.length - 1; i >= 0; i--) {
            const link = this.links[i];
            if (link.isCurveHit(worldX, worldY, this.scale)) {
              return link;
            }
          }
          return null;
        }

        // Select a link
        selectLink(link) {
          // Deselect all links first
          this.links.forEach(l => (l.isSelected = false));

          // Select the clicked link
          if (link) {
            link.isSelected = true;
            this.selectedLink = link;
          } else {
            this.selectedLink = null;
          }

          this.draw();
        }

        // Toggle link mode
        toggleLinkMode() {
          this.isLinkMode = !this.isLinkMode;
          this.linkModeFirstNode = null;

          const addLinkBtn = document.getElementById('addLink');
          const linkModeInfo = document.getElementById('linkModeInfo');

          if (this.isLinkMode) {
            addLinkBtn.classList.add('active');
            linkModeInfo.style.display = 'block';
          } else {
            addLinkBtn.classList.remove('active');
            linkModeInfo.style.display = 'none';
          }
        }

        // Handle link mode node clicks
        handleLinkModeClick(node) {
          if (!this.linkModeFirstNode) {
            // First node selected
            this.linkModeFirstNode = node;
            node.isSelected = true;
            this.draw();
          } else {
            // Second node selected, create link
            if (this.linkModeFirstNode !== node) {
              this.addLink(this.linkModeFirstNode, node);
            }

            // Reset link mode
            this.linkModeFirstNode.isSelected = false;
            this.linkModeFirstNode = null;
            this.toggleLinkMode();
          }
        }
      }

      // Initialize the canvas map when the page loads
      window.addEventListener('load', () => {
        const canvasMap = new CanvasMap('canvas');
        canvasMap.updateInfo();
      });
    </script>
  </body>
</html>
